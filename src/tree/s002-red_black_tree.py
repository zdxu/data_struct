# -*- coding: utf-8 -*-

# 一种含有红黑结点并能够自平衡的二叉树，满足以下性质：
# 性质一：每个结点要么是黑色要么是红色
# 性质二：根结点是黑色
# 性质三：每个叶子结点是黑色（叶子结点是 null 结点，不包含数据只是充当树在此结束的指示）
# 性质四：每个红色结点的两个子结点一定是黑色结点
# 性质五：任意结点到每个叶子结点的路径都包含相同数量的黑结点

# ----  当前结点为黑色或空树时  ----
# 当前结点是根结点或者树为空树 直接插
# 当前结点是黑色 插入结点置为红色即可（原先一定是红黑树，满足性质五，置为红色后任然满足性质五）

# 左倾
# ----  当前结点为红色，则父结点也必是黑色  ----
#       1、无同级结点(当前结点为树尾结点)，先插入后转换
#           黑                            黑（原当前）
#       红（当前）        ->          红        红（原黑）
#   红

#           黑                            黑
#       红（当前）        ->          红（原当前）红（原黑）
#           红

#
#       2、有同级结点，先转换后插入
#       a、同级结点为红色，
#       步骤-：
#               黑                            红（原黑）                               红（原黑）
#           红（当前）红      ->           黑（当前）黑（同级）         ->            黑（当前）黑（同级）
#       红                                                                     红

#               黑                            红（原黑）                               红（原黑）
#           红（当前）红      ->           黑（当前）黑（同级）           ->          黑（插入）黑（同级）
#               红                            红                               红（当前）
#      步骤二：已父结点为当前结点，插入已祖父结点为树末结点的树即作为祖父结点的子结点，循环利用1、2的方法，不同之处是在祖父结点的插入
# 可能会遇到
#            黑
#       红       黑       这种情况同方法1


#       叔叔结点是红色，插入结点维持红色不变，将父结点及叔叔结点置为黑色，若祖父结点不为根结点置为红色，

# ---- 若祖父结点的父结点为黑色，插入结束

# ---- 若祖父结点的父结点为红色，以祖父结点为当前结点

# ---- 若无叔叔结点或叔叔结点也为红色时，重复步骤一

# ---- 若叔叔结点为黑色，当前结点为右子结点
# 步骤二：以当前结点为支点左旋，然后以祖父结点为当前结点
# ---- 当前结点为左子结点且祖父结点为红色，叔叔结点为黑色
# 步骤三：以当前结点为支点右旋，然后以祖父结点为当前结点
# 。。。

# ----  若叔叔结点为黑色，当前结点为左子结点
# 上述右子结点的步骤二、三调换顺序

# 步骤四：判断根结点是否是黑色，非黑色则置黑，插入结束


# 删除最终都转换成了，树尾结点替换并删除树尾结点

# 步骤-：查找树尾替换结点

# 替换结点为红色 直接删

# 替换结点为黑色
# 黑 红 黑
#    1 叔结点有少于两个子结点 以父结点为当前结点旋转，树尾结点置红
#    2 叔结点有两个子结点 以父结点为当前结点旋转，树尾结点置红 + 新插入叔结点的一个子结点
# 黑 黑 红
#
